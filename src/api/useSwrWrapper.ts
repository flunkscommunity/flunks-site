import { AxiosPromise, AxiosRequestConfig } from "axios";
import useSWR, { SWRConfiguration } from "swr";
import useSWRInfinite, { SWRInfiniteResponse } from "swr/infinite";

export interface ExtendedSWRConfiguration extends SWRConfiguration {
  /**
   * Utility to conditionally fetch data.
   * Useful when waiting on a parameter to resolve.
   * @default true
   * @see https://swr.vercel.app/docs/conditional-fetching
   */
  shouldFetch?: boolean;
}

/** Small bit of typescript magic, type A here is unknown until a fetcher is passed in
 * and then it is inferred from the fetcher as the fetchers request parameters - so
 * when using this wrapper, you should get type safety and autocomplete for the fetcher
 * parameters
 **/
export interface UseSwrWrapperParams<T, A> {
  fetcher: (
    requestParameters: A,
    options?: AxiosRequestConfig
  ) => AxiosPromise<T>;
  requestParameters: A;
  options?: AxiosRequestConfig;
  swrConfig?: ExtendedSWRConfiguration;
  key?: string;
}

/**
 * This is a wrapper around the useSWR hook that allows us to pass in a fetcher function
 * that is generated by openapi-generator. This fetcher function takes in a set of requestParameters
 * and returns a promise that resolves to the data we want to display.
 *
 * This wrapper also allows us to pass in a key that will be used to cache the data in SWR.
 * It's crucial that we use a key that is unique to the data we want to display. For example,
 * if we want to display a list of users, we should use a key like "users".
 */
export const useSwrWrapper = <T, A>(params: UseSwrWrapperParams<T, A>) => {
  const { fetcher, requestParameters, options, swrConfig, key } = params;
  const { shouldFetch = true } = swrConfig || {};

  const fetcherWrapper = async () => {
    const res = await fetcher(requestParameters, options);

    return res.data;
  };

  return useSWR(
    shouldFetch ? [key, ...Object.values(requestParameters as object)] : null,
    fetcherWrapper,
    swrConfig
  );
};

export interface PaginatedResponse<T> {
  page: number;
  totalPages: number;
  pageSize: number;
  totalCount: number;
  items: T[];
}

const defaultGetKey =
  <T>(cacheKey: string) =>
  (pageIndex: number, previousPageData: T[]) => {
    const isLastPage = previousPageData && !previousPageData.length;

    if (isLastPage) {
      return [cacheKey, null];
    }

    /*
     * These array items are passed to the fetcher as arguments.
     * We need to return the cacheKey as the first index of this array as
     * SWR uses this syntax to determine the cache key and whether to revalidate data
     * when the other items of this array change
     * https://swr.vercel.app/docs/advanced/cache
     */
    return [cacheKey, `${pageIndex + 1}`];
  };

export interface UseSwrInfiniteWrapperParams<T, A> {
  fetcher: (
    requestParameters: A,
    options?: AxiosRequestConfig
  ) => AxiosPromise<T>;
  requestParameters: A;
  options?: AxiosRequestConfig;
  swrConfig?: ExtendedSWRConfiguration;
  cacheKey: string;
}

/**
 * This is a wrapper around the useSWRInfinite hook that allows us to pass in a fetcher function
 * that is generated by openapi-generator. This fetcher function that supports paginated query
 * parameters and returns a promise that resolves to the data we want to display.
 *
 * This wrapper also allows us to pass in a cacheKey that will be used to cache the data in SWR.
 * It's crucial that we use a cacheKey that is unique to the data we want to display. For example,
 * if we want to display a list of users, we should use a cacheKey like "users".
 */
export const useSwrInfiniteWrapper = <T, A>(
  params: UseSwrInfiniteWrapperParams<T, A>
): SWRInfiniteResponse<T, Error> => {
  const { fetcher, requestParameters, options, swrConfig, cacheKey } = params;

  // defaultGetKey's return is an array of parameters that will be passed to the fetcher
  // We don't use the "_" parameter as it's a fixed cachekey (created in defaultGetKey) used to
  // separate different caches in the SWR global cache state
  const fetcherWrapper = async (_: string, swrPage: number) => {
    console.log("useSwrInfiniteWrapper", swrPage)
    const res = await fetcher(
      {
        ...requestParameters,
        page: swrPage,
      },
      options
    )
      .then((res) => {
        return res.data;
      })
      .catch((err) => {
        console.error("ERROR: useSwrInfiniteWrapper", err);
        throw err;
      });

    return res;
  };

  return useSWRInfinite(defaultGetKey<T>(cacheKey), fetcherWrapper, swrConfig);
};
