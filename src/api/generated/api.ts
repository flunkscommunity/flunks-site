/* tslint:disable */
/* eslint-disable */
/**
 * Flunks API
 * Flunks Marketplace API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateCollectionDto
 */
export interface CreateCollectionDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionDto
     */
    'nftType': string;
    /**
     * 
     * @type {object}
     * @memberof CreateCollectionDto
     */
    'metadata': object;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionDto
     */
    'totalSupply': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionDto
     */
    'floorPrice': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionDto
     */
    'activeListings': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionDto
     */
    'tradingVolume': number;
    /**
     * 
     * @type {number}
     * @memberof CreateCollectionDto
     */
    'uniqueHolders': number;
}
/**
 * 
 * @export
 * @interface GetActivityDto
 */
export interface GetActivityDto {
    /**
     * 
     * @type {number}
     * @memberof GetActivityDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'collectionName': string;
    /**
     * 
     * @type {number}
     * @memberof GetActivityDto
     */
    'tokenId': number;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'activity': string;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'eventDate': string;
    /**
     * 
     * @type {object}
     * @memberof GetActivityDto
     */
    'price': object;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof GetActivityDto
     */
    'listingResourceId': string;
    /**
     * 
     * @type {NftDto}
     * @memberof GetActivityDto
     */
    'NFT': NftDto;
}
/**
 * 
 * @export
 * @interface GetListingDto
 */
export interface GetListingDto {
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'listingResourceId': string;
    /**
     * 
     * @type {number}
     * @memberof GetListingDto
     */
    'listingId': number;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'collectionName': string;
    /**
     * 
     * @type {number}
     * @memberof GetListingDto
     */
    'tokenId': number;
    /**
     * 
     * @type {number}
     * @memberof GetListingDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'sellerAddress': string;
    /**
     * 
     * @type {number}
     * @memberof GetListingDto
     */
    'expiry': number;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'expiryDate': string;
    /**
     * 
     * @type {string}
     * @memberof GetListingDto
     */
    'transactionId': string;
}
/**
 * 
 * @export
 * @interface GetUserWalletNftsDto
 */
export interface GetUserWalletNftsDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserWalletNftsDto
     */
    'Flunks': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserWalletNftsDto
     */
    'Backpack': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserWalletNftsDto
     */
    'Patch': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserWalletNftsDto
     */
    'InceptionAvatar': Array<string>;
}
/**
 * 
 * @export
 * @interface MarketplaceIndividualNftDto
 */
export interface MarketplaceIndividualNftDto {
    /**
     * 
     * @type {string}
     * @memberof MarketplaceIndividualNftDto
     */
    'collectionName': string;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceIndividualNftDto
     */
    'tokenId': number;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceIndividualNftDto
     */
    'templateId': number;
    /**
     * 
     * @type {object}
     * @memberof MarketplaceIndividualNftDto
     */
    'metadata': object;
    /**
     * 
     * @type {Array<GetListingDto>}
     * @memberof MarketplaceIndividualNftDto
     */
    'Listing': Array<GetListingDto>;
    /**
     * 
     * @type {Array<GetListingDto>}
     * @memberof MarketplaceIndividualNftDto
     */
    'ExternalListing': Array<GetListingDto>;
    /**
     * 
     * @type {Array<NftActivityDto>}
     * @memberof MarketplaceIndividualNftDto
     */
    'NftActivity': Array<NftActivityDto>;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceIndividualNftDto
     */
    'floorPrice': number;
    /**
     * 
     * @type {string}
     * @memberof MarketplaceIndividualNftDto
     */
    'floorPriceCurrency': string;
    /**
     * 
     * @type {string}
     * @memberof MarketplaceIndividualNftDto
     */
    'listingDate': string;
    /**
     * 
     * @type {string}
     * @memberof MarketplaceIndividualNftDto
     */
    'expiryDate': string;
    /**
     * 
     * @type {number}
     * @memberof MarketplaceIndividualNftDto
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof MarketplaceIndividualNftDto
     */
    'ownerAddress': string;
}
/**
 * 
 * @export
 * @interface NftActivityDto
 */
export interface NftActivityDto {
    /**
     * 
     * @type {number}
     * @memberof NftActivityDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'collectionName': string;
    /**
     * 
     * @type {number}
     * @memberof NftActivityDto
     */
    'tokenId': number;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'activity': string;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'eventDate': string;
    /**
     * 
     * @type {number}
     * @memberof NftActivityDto
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof NftActivityDto
     */
    'listingResourceId': string;
}
/**
 * 
 * @export
 * @interface NftDto
 */
export interface NftDto {
    /**
     * 
     * @type {string}
     * @memberof NftDto
     */
    'collectionName': string;
    /**
     * 
     * @type {number}
     * @memberof NftDto
     */
    'tokenId': number;
    /**
     * 
     * @type {number}
     * @memberof NftDto
     */
    'templateId': number;
    /**
     * 
     * @type {string}
     * @memberof NftDto
     */
    'ownerAddress': string;
    /**
     * 
     * @type {number}
     * @memberof NftDto
     */
    'floorPrice': number;
    /**
     * 
     * @type {string}
     * @memberof NftDto
     */
    'floorPriceCurrency': string;
    /**
     * 
     * @type {string}
     * @memberof NftDto
     */
    'listingDate': string;
    /**
     * 
     * @type {string}
     * @memberof NftDto
     */
    'expiryDate': string;
    /**
     * 
     * @type {number}
     * @memberof NftDto
     */
    'rank': number;
    /**
     * 
     * @type {object}
     * @memberof NftDto
     */
    'metadata': object;
    /**
     * 
     * @type {Array<GetListingDto>}
     * @memberof NftDto
     */
    'Listing': Array<GetListingDto>;
    /**
     * 
     * @type {Array<GetListingDto>}
     * @memberof NftDto
     */
    'ExternalListing': Array<GetListingDto>;
}

/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} searchByCollectionNames 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [collectionNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetAllCollectionActivities: async (searchByCollectionNames: Array<string>, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, collectionNames?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchByCollectionNames' is not null or undefined
            assertParamExists('collectionControllerGetAllCollectionActivities', 'searchByCollectionNames', searchByCollectionNames)
            const localVarPath = `/collection/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activities !== undefined) {
                localVarQueryParameter['activities'] = activities;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (searchByCollectionNames) {
                localVarQueryParameter['searchByCollectionNames'] = searchByCollectionNames;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (collectionNames !== undefined) {
                localVarQueryParameter['collectionNames'] = collectionNames;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetCollectionByName: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('collectionControllerGetCollectionByName', 'collectionName', collectionName)
            const localVarPath = `/collection/{collectionName}/status`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} tokenId 
         * @param {any} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetNftByCollectionNameAndTokenId: async (tokenId: number, collectionName: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('collectionControllerGetNftByCollectionNameAndTokenId', 'tokenId', tokenId)
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('collectionControllerGetNftByCollectionNameAndTokenId', 'collectionName', collectionName)
            const localVarPath = `/collection/{collectionName}/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} collectionName 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC'} [sort] 
         * @param {'LISTED' | 'NOT_LISTED' | 'ALL'} [include] 
         * @param {string} [traits] Strategy: \&#39;AND\&#39; when trait names are the same; \&#39;OR\&#39; when trait names are different
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetallNftsInACollection: async (collectionName: any, page?: number, limit?: number, sort?: 'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC', include?: 'LISTED' | 'NOT_LISTED' | 'ALL', traits?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('collectionControllerGetallNftsInACollection', 'collectionName', collectionName)
            const localVarPath = `/collection/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (traits !== undefined) {
                localVarQueryParameter['traits'] = traits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} searchByCollectionNames 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [collectionNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionControllerGetAllCollectionActivities(searchByCollectionNames: Array<string>, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, collectionNames?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActivityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionControllerGetAllCollectionActivities(searchByCollectionNames, activities, sort, page, limit, collectionNames, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionControllerGetCollectionByName(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateCollectionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionControllerGetCollectionByName(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} tokenId 
         * @param {any} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionControllerGetNftByCollectionNameAndTokenId(tokenId: number, collectionName: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceIndividualNftDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionControllerGetNftByCollectionNameAndTokenId(tokenId, collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} collectionName 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC'} [sort] 
         * @param {'LISTED' | 'NOT_LISTED' | 'ALL'} [include] 
         * @param {string} [traits] Strategy: \&#39;AND\&#39; when trait names are the same; \&#39;OR\&#39; when trait names are different
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionControllerGetallNftsInACollection(collectionName: any, page?: number, limit?: number, sort?: 'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC', include?: 'LISTED' | 'NOT_LISTED' | 'ALL', traits?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MarketplaceIndividualNftDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionControllerGetallNftsInACollection(collectionName, page, limit, sort, include, traits, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<string>} searchByCollectionNames 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [collectionNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetAllCollectionActivities(searchByCollectionNames: Array<string>, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, collectionNames?: string, options?: any): AxiosPromise<Array<GetActivityDto>> {
            return localVarFp.collectionControllerGetAllCollectionActivities(searchByCollectionNames, activities, sort, page, limit, collectionNames, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetCollectionByName(collectionName: string, options?: any): AxiosPromise<Array<CreateCollectionDto>> {
            return localVarFp.collectionControllerGetCollectionByName(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} tokenId 
         * @param {any} collectionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetNftByCollectionNameAndTokenId(tokenId: number, collectionName: any, options?: any): AxiosPromise<MarketplaceIndividualNftDto> {
            return localVarFp.collectionControllerGetNftByCollectionNameAndTokenId(tokenId, collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} collectionName 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC'} [sort] 
         * @param {'LISTED' | 'NOT_LISTED' | 'ALL'} [include] 
         * @param {string} [traits] Strategy: \&#39;AND\&#39; when trait names are the same; \&#39;OR\&#39; when trait names are different
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionControllerGetallNftsInACollection(collectionName: any, page?: number, limit?: number, sort?: 'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC', include?: 'LISTED' | 'NOT_LISTED' | 'ALL', traits?: string, options?: any): AxiosPromise<Array<MarketplaceIndividualNftDto>> {
            return localVarFp.collectionControllerGetallNftsInACollection(collectionName, page, limit, sort, include, traits, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for collectionControllerGetAllCollectionActivities operation in CollectionApi.
 * @export
 * @interface CollectionApiCollectionControllerGetAllCollectionActivitiesRequest
 */
export interface CollectionApiCollectionControllerGetAllCollectionActivitiesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly searchByCollectionNames: Array<string>

    /**
     * 
     * @type {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'

    /**
     * 
     * @type {'DATE_ASC' | 'DATE_DESC'}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly sort?: 'DATE_ASC' | 'DATE_DESC'

    /**
     * 
     * @type {number}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof CollectionApiCollectionControllerGetAllCollectionActivities
     */
    readonly collectionNames?: string
}

/**
 * Request parameters for collectionControllerGetCollectionByName operation in CollectionApi.
 * @export
 * @interface CollectionApiCollectionControllerGetCollectionByNameRequest
 */
export interface CollectionApiCollectionControllerGetCollectionByNameRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionApiCollectionControllerGetCollectionByName
     */
    readonly collectionName: string
}

/**
 * Request parameters for collectionControllerGetNftByCollectionNameAndTokenId operation in CollectionApi.
 * @export
 * @interface CollectionApiCollectionControllerGetNftByCollectionNameAndTokenIdRequest
 */
export interface CollectionApiCollectionControllerGetNftByCollectionNameAndTokenIdRequest {
    /**
     * 
     * @type {number}
     * @memberof CollectionApiCollectionControllerGetNftByCollectionNameAndTokenId
     */
    readonly tokenId: number

    /**
     * 
     * @type {any}
     * @memberof CollectionApiCollectionControllerGetNftByCollectionNameAndTokenId
     */
    readonly collectionName: any
}

/**
 * Request parameters for collectionControllerGetallNftsInACollection operation in CollectionApi.
 * @export
 * @interface CollectionApiCollectionControllerGetallNftsInACollectionRequest
 */
export interface CollectionApiCollectionControllerGetallNftsInACollectionRequest {
    /**
     * 
     * @type {any}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly collectionName: any

    /**
     * 
     * @type {number}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly limit?: number

    /**
     * 
     * @type {'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC'}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly sort?: 'PRICE_ASC' | 'PRICE_DESC' | 'DATE_ASC' | 'DATE_DESC' | 'RANK_ASC' | 'RANK_DESC'

    /**
     * 
     * @type {'LISTED' | 'NOT_LISTED' | 'ALL'}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly include?: 'LISTED' | 'NOT_LISTED' | 'ALL'

    /**
     * Strategy: \&#39;AND\&#39; when trait names are the same; \&#39;OR\&#39; when trait names are different
     * @type {string}
     * @memberof CollectionApiCollectionControllerGetallNftsInACollection
     */
    readonly traits?: string
}

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @param {CollectionApiCollectionControllerGetAllCollectionActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionControllerGetAllCollectionActivities(requestParameters: CollectionApiCollectionControllerGetAllCollectionActivitiesRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionControllerGetAllCollectionActivities(requestParameters.searchByCollectionNames, requestParameters.activities, requestParameters.sort, requestParameters.page, requestParameters.limit, requestParameters.collectionNames, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionApiCollectionControllerGetCollectionByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionControllerGetCollectionByName(requestParameters: CollectionApiCollectionControllerGetCollectionByNameRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionControllerGetCollectionByName(requestParameters.collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionApiCollectionControllerGetNftByCollectionNameAndTokenIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionControllerGetNftByCollectionNameAndTokenId(requestParameters: CollectionApiCollectionControllerGetNftByCollectionNameAndTokenIdRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionControllerGetNftByCollectionNameAndTokenId(requestParameters.tokenId, requestParameters.collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionApiCollectionControllerGetallNftsInACollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public collectionControllerGetallNftsInACollection(requestParameters: CollectionApiCollectionControllerGetallNftsInACollectionRequest, options?: AxiosRequestConfig) {
        return CollectionApiFp(this.configuration).collectionControllerGetallNftsInACollection(requestParameters.collectionName, requestParameters.page, requestParameters.limit, requestParameters.sort, requestParameters.include, requestParameters.traits, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} walletAddress 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetActivitiesByWalletAddress: async (walletAddress: string, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('usersControllerGetActivitiesByWalletAddress', 'walletAddress', walletAddress)
            const localVarPath = `/users/{walletAddress}/activities`
                .replace(`{${"walletAddress"}}`, encodeURIComponent(String(walletAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activities !== undefined) {
                localVarQueryParameter['activities'] = activities;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserNftsByWalletAddress: async (walletAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletAddress' is not null or undefined
            assertParamExists('usersControllerGetUserNftsByWalletAddress', 'walletAddress', walletAddress)
            const localVarPath = `/users/{walletAddress}`
                .replace(`{${"walletAddress"}}`, encodeURIComponent(String(walletAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} walletAddress 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetActivitiesByWalletAddress(walletAddress: string, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetActivityDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetActivitiesByWalletAddress(walletAddress, activities, sort, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetUserNftsByWalletAddress(walletAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWalletNftsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetUserNftsByWalletAddress(walletAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} walletAddress 
         * @param {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'} [activities] 
         * @param {'DATE_ASC' | 'DATE_DESC'} [sort] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetActivitiesByWalletAddress(walletAddress: string, activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED', sort?: 'DATE_ASC' | 'DATE_DESC', page?: number, limit?: number, options?: any): AxiosPromise<Array<GetActivityDto>> {
            return localVarFp.usersControllerGetActivitiesByWalletAddress(walletAddress, activities, sort, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} walletAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetUserNftsByWalletAddress(walletAddress: string, options?: any): AxiosPromise<GetUserWalletNftsDto> {
            return localVarFp.usersControllerGetUserNftsByWalletAddress(walletAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersControllerGetActivitiesByWalletAddress operation in UsersApi.
 * @export
 * @interface UsersApiUsersControllerGetActivitiesByWalletAddressRequest
 */
export interface UsersApiUsersControllerGetActivitiesByWalletAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersControllerGetActivitiesByWalletAddress
     */
    readonly walletAddress: string

    /**
     * 
     * @type {'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'}
     * @memberof UsersApiUsersControllerGetActivitiesByWalletAddress
     */
    readonly activities?: 'MINT' | 'BURN' | 'TRANSFER' | 'LIST' | 'DELIST' | 'SALE' | 'PATCH_ADDED' | 'PATCH_REMOVED'

    /**
     * 
     * @type {'DATE_ASC' | 'DATE_DESC'}
     * @memberof UsersApiUsersControllerGetActivitiesByWalletAddress
     */
    readonly sort?: 'DATE_ASC' | 'DATE_DESC'

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersControllerGetActivitiesByWalletAddress
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiUsersControllerGetActivitiesByWalletAddress
     */
    readonly limit?: number
}

/**
 * Request parameters for usersControllerGetUserNftsByWalletAddress operation in UsersApi.
 * @export
 * @interface UsersApiUsersControllerGetUserNftsByWalletAddressRequest
 */
export interface UsersApiUsersControllerGetUserNftsByWalletAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersControllerGetUserNftsByWalletAddress
     */
    readonly walletAddress: string
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {UsersApiUsersControllerGetActivitiesByWalletAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetActivitiesByWalletAddress(requestParameters: UsersApiUsersControllerGetActivitiesByWalletAddressRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetActivitiesByWalletAddress(requestParameters.walletAddress, requestParameters.activities, requestParameters.sort, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersControllerGetUserNftsByWalletAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetUserNftsByWalletAddress(requestParameters: UsersApiUsersControllerGetUserNftsByWalletAddressRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetUserNftsByWalletAddress(requestParameters.walletAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


